# runner.py
# Host code to load, compile, and run the OpenCL kernel.

import jinja2
import numpy as np
import socket
import json
import time
import sys # Import sys for error logging
import argparse # Import argparse

# --- Mining Pool Configuration (Placeholder) ---
POOL_HOST = "doge.zsolo.bid"
POOL_PORT = 8057
POOL_USER = "DGKsuHU6XdghZtA2aWGqvrZrkWracQJzPd"
POOL_PASS = "x"

class StratumClient:
    def __init__(self, host, port, user, password):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.sock = None
        self.file = None
        self.job_id = None
        self.extranonce1 = None
        self.extranonce2_size = None
        self.target = None
        self.extranonce2_int = 0 # Initialize extranonce2_int
        self.kernel_nonce = np.uint32(0) # Initialize kernel_nonce

    def connect(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            self.sock.settimeout(60) # Set a timeout for socket operations
            self.file = self.sock.makefile('rwb', 0) # 0 for unbuffered
            print(f"Connected to mining pool: {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Error connecting to pool: {e}")
            return False

    def send_message(self, method, params, _id=1):
        message = {"id": _id, "method": method, "params": params}
        self.file.write(json.dumps(message).encode('utf-8') + b'\n')
        self.file.flush()

    def receive_message(self):
        try:
            line = self.file.readline()
            if line:
                return json.loads(line.decode('utf-8'))
            return None
        except socket.timeout:
            return None # No message within timeout
        except Exception as e:
            print(f"Error receiving message: {e}")
            return None

    def subscribe_and_authorize(self):
        self.send_message("mining.subscribe", ["scrypt-miner/1.0"])
        response = self.receive_message()
        if response and "result" in response:
            # Extract extranonce1 and extranonce2_size
            self.extranonce1 = response["result"][1]
            self.extranonce2_size = response["result"][2]
            print(f"Subscribed. Extranonce1: {self.extranonce1}, Extranonce2 Size: {self.extranonce2_size}")
        else:
            print("Failed to subscribe.")
            return False

        self.send_message("mining.authorize", [self.user, self.password])
        response = self.receive_message()
        if response and response.get("result") is True:
            print("Authorized successfully.")
            return True
        else:
            print(f"Authorization failed: {response.get('error')}")
            return False

    def handle_notification(self, notification):
        method = notification.get("method")
        params = notification.get("params")

        if method == "mining.notify":
            self.job_id = params[0]
            self.target = params[7] # This is the target in hex string format
            clean_jobs = params[8]

            print(f"New job received. Job ID: {self.job_id}, Target: {self.target}, Clean Jobs: {clean_jobs}")

            if clean_jobs:
                self.extranonce2_int = 0 # Reset extranonce2
                self.kernel_nonce = np.uint32(0) # Reset kernel nonce

            return True
        elif method == "mining.set_difficulty":
            difficulty = params[0]
            print(f"New difficulty set: {difficulty}")
            # You might need to convert this difficulty to a target hash for your kernel
            return True
        elif method == "mining.set_extranonce":
            self.extranonce1 = params[0]
            self.extranonce2_size = params[1]
            print(f"New extranonce received. Extranonce1: {self.extranonce1}, Extranonce2 Size: {self.extranonce2_size}")
            return True
        return False

    def submit_share(self, extranonce2, ntime, nonce, hash_result):
        # hash_result should be the 32-byte hash from the kernel, in hex
        # Stratum expects little-endian hashes, so we might need to reverse byte order
        # The nonce here is the kernel's nonce, not the extranonce2
        params = [
            self.user,
            self.job_id,
            extranonce2, # This is the extranonce2 generated by the miner
            ntime,       # ntime from the job
            nonce,       # nonce from the kernel
            hash_result  # hash from the kernel
        ]
        self.send_message("mining.submit", params)
        response = self.receive_message()
        if response and response.get("result") is True:
            print("Share accepted!")
            return True
        else:
            print(f"Share rejected: {response.get('error')}")
            return False

def sha256d(data):
    # Performs SHA256(SHA256(data))
    import hashlib
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def construct_block_header(job_params, extranonce1, extranonce2_bytes, kernel_nonce):
    # job_params: [job_id, prevhash, coinb1, coinb2, merkle_branch, version, nbits, ntime, clean_jobs]
    # extranonce1: from mining.subscribe
    # extranonce2_bytes: bytes representation of extranonce2 (incremented by miner)
    # kernel_nonce: the nonce from the OpenCL kernel

    # Extract components from job_params
    prevhash_hex = job_params[1]
    coinb1_hex = job_params[2]
    coinb2_hex = job_params[3]
    merkle_branch_hex = job_params[4] # List of hex strings
    version_hex = job_params[5]
    nbits_hex = job_params[6]
    ntime_hex = job_params[7]

    # Convert hex to bytes and handle byte order
    # Bitcoin/Dogecoin uses little-endian for hashes and some other fields
    version_bytes = bytes.fromhex(version_hex)[::-1]
    prevhash_bytes = bytes.fromhex(prevhash_hex)[::-1]
    nbits_bytes = bytes.fromhex(nbits_hex)[::-1]
    ntime_bytes = bytes.fromhex(ntime_hex)[::-1]
    kernel_nonce_bytes = kernel_nonce.tobytes() # Already np.uint32, so 4 bytes

    # Construct coinbase transaction
    coinbase_tx = bytes.fromhex(coinb1_hex) + bytes.fromhex(extranonce1) + extranonce2_bytes + bytes.fromhex(coinb2_hex)

    # Compute Merkle Root
    # Hash the coinbase transaction
    coinbase_hash = sha256d(coinbase_tx)

    # Combine with merkle_branch hashes
    merkle_root = coinbase_hash
    for h in merkle_branch_hex:
        h_bytes = bytes.fromhex(h)[::-1] # Reverse for little-endian
        merkle_root = sha256d(merkle_root + h_bytes)
    merkle_root_bytes = merkle_root

    # Assemble the 80-byte block header
    block_header = (
        version_bytes +
        prevhash_bytes +
        merkle_root_bytes + # This needs to be correctly calculated
        ntime_bytes +
        nbits_bytes +
        kernel_nonce_bytes
    )

    return block_header


# Try to import PyOpenCL
try:
    import pyopencl as cl
    print("PyOpenCL imported successfully.")
except ImportError:
    print("Error: PyOpenCL could not be imported.")
    print("Please ensure PyOpenCL is installed correctly.")
    exit()

def main():
    try: # General error handling for the entire main function
        # Redirect stderr to a log file
        sys.stderr = open("miner_error.log", "a")
        print("Starting OpenCL runner...")

        # Parse command-line arguments for pool configuration
        parser = argparse.ArgumentParser(description="Dogecoin Scrypt OpenCL Miner")
        parser.add_argument("--pool-host", type=str, default=POOL_HOST,
                            help="Mining pool hostname or IP address")
        parser.add_argument("--pool-port", type=int, default=POOL_PORT,
                            help="Mining pool port")
        parser.add_argument("--pool-user", type=str, default=POOL_USER,
                            help="Mining pool username (wallet address.worker_name)")
        parser.add_argument("--pool-pass", type=str, default=POOL_PASS,
                            help="Mining pool password (usually 'x')")
        args = parser.parse_args()

        # Use arguments, falling back to hardcoded defaults if not provided
        pool_host = args.pool_host
        pool_port = args.pool_port
        pool_user = args.pool_user
        pool_pass = args.pool_pass

        # 0. Initialize OpenCL
        try:
            platform = cl.get_platforms()[0]
            device = cl.get_platforms()[0].get_devices()[0]
            context = cl.Context([device])
            queue = cl.CommandQueue(context)
            print(f"OpenCL initialized with device: {device.name}")
        except Exception as e:
            print(f"Error initializing OpenCL: {e}")
            print("Please ensure OpenCL drivers are installed and a compatible device is available.")
            return

        # 0.1 Initialize Stratum Client
        client = StratumClient(pool_host, pool_port, pool_user, pool_pass)
        if not client.connect():
            return
        if not client.subscribe_and_authorize():
            return

        # 1. Load and render the Jinja2 template
        try:
            template_loader = jinja2.FileSystemLoader(searchpath="N:/miner/NBMiner_42.3_Win/scrypt/scrypt_doge/kernels")
            template_env = jinja2.Environment(loader=template_loader)
            template = template_env.get_template("scrypt_core.cl.jinja")
        except jinja2.exceptions.TemplateNotFound as e:
            print(f"Error loading kernel template: {e}")
            print("Please ensure the file 'kernels/scrypt_core.cl.jinja' exists.")
            return

        # Get parameters from scrypt_doge.toml (or use defaults for now)
        params = {
            'unroll': 8,
            'vector_width': 4,
            'tile_bytes': 131072
        }
        
        rendered_kernel = template.render(**params)
        print("--- Rendered Kernel (first 200 chars) ---")
        print(rendered_kernel[:200])
        print("------------------------------------\n")

        # 2. Create and build the OpenCL program
        try:
            program = cl.Program(context, rendered_kernel).build()
        except cl.LogicError as e:
            print("OpenCL Program Build Error:")
            print(e)
            if hasattr(e, 'build_log') and context.devices:
                for device in context.devices:
                    print(f"Build log for device {device.name}:")
                    print(e.build_log.get(device, 'No build log available'))
            return # Use return instead of exit() to allow main() to finish gracefully

        # 3. Prepare data and launch kernel
        print("Listening for mining jobs...")

        # Main mining loop
        while True:
            try:
                message = client.receive_message()
                if message:
                    if message.get("method"):
                        # Handle notifications (mining.notify, mining.set_difficulty, etc.)
                        client.handle_notification(message)
                        if client.job_id: # If a new job was set by handle_notification
                            # --- Construct Block Header (input_data) ---
                            # This is a simplified construction. A real miner needs to handle
                            # Merkle tree calculation, extranonce2 incrementing, etc. 
                            # For now, we'll use a placeholder for the actual block header construction
                            # based on the Stratum job details.

                            # Example of how input_data might be constructed (simplified):
                            # prevhash_bytes = bytes.fromhex(client.prevhash)[::-1] # Reverse for little-endian
                            # coinb1_bytes = bytes.fromhex(client.coinb1)
                            # coinb2_bytes = bytes.fromhex(client.coinb2)
                            # extranonce2_bytes = b'\x00' * client.extranonce2_size # Placeholder
                            # ntime_bytes = int(client.ntime, 16).to_bytes(4, 'little')
                            # nonce_bytes = np.uint32(0).tobytes() # Starting nonce for this job

                            # block_header_parts = [
                            #     version_bytes, # From job
                            #     prevhash_bytes,
                            #     merkle_root_bytes, # Needs to be calculated from coinb1, coinb2, extranonces
                            #     ntime_bytes,
                            #     difficulty_target_bytes, # From job
                            #     nonce_bytes
                            # ]
                            # input_data = b''.join(block_header_parts)

                            # Use client's extranonce2_int and kernel_nonce, which are reset by handle_notification if clean_jobs is true
                            extranonce2_bytes = client.extranonce2_int.to_bytes(client.extranonce2_size, 'little')

                            # Construct the real block header
                            input_data = construct_block_header(
                                job_params=message["params"], # Pass the full params from mining.notify
                                extranonce1=client.extranonce1,
                                extranonce2_bytes=extranonce2_bytes,
                                kernel_nonce=client.kernel_nonce # The kernel's nonce will be part of the header
                            )

                            # Ensure input_data is 80 bytes
                            if len(input_data) != 80:
                                print(f"Error: Constructed block header is not 80 bytes! Length: {len(input_data)}")
                                continue # Skip this job

                            # Create GPU buffers (re-create if input_data size changes, though it should be fixed at 80 bytes)
                            mf = cl.mem_flags
                            input_buf = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=input_data)
                            output_buf = cl.Buffer(context, mf.WRITE_ONLY, 32) # Output is 32 bytes (hash)
                            v_buf = cl.Buffer(context, mf.READ_WRITE, 131072) # Scrypt V buffer

                            # Get the kernel function
                            scrypt_kernel = program.scrypt_kernel

                            # Define global and local work sizes
                            global_size = (1,) # One work-item for now
                            local_size = None # Let OpenCL choose

                            # --- Mining Loop for current job ---
                            # This loop will iterate through nonces for the current job
                            # until a share is found or a new job is received.
                            max_nonces_per_job = 10000 # Limit for testing
                            current_nonce_attempt = 0

                            while True: # Loop indefinitely for nonces and extranonce2
                                try:
                                    event = scrypt_kernel(queue, global_size, local_size, input_buf, output_buf, client.kernel_nonce, v_buf)
                                    event.wait() # Wait for kernel to complete

                                    # Read output data (hash)
                                    output_hash_bytes = np.empty(32, dtype=np.uint8)
                                    cl.enqueue_copy(queue, output_hash_bytes, output_buf).wait()
                                    output_hash_hex = output_hash_bytes.tobytes().hex()

                                    print(f"Job ID: {client.job_id}, Nonce: {client.kernel_nonce}, Hash: {output_hash_hex}")

                                    # --- Share Validation and Submission ---
                                    # Convert target from hex string to big-endian integer
                                    # Stratum target is usually little-endian hex, so reverse it for big-endian int conversion
                                    target_bytes = bytes.fromhex(client.target)[::-1]
                                    target_int = int.from_bytes(target_bytes, 'big')

                                    # Convert output hash from kernel to big-endian integer
                                    # The output_hash_bytes is already in little-endian from the kernel, so reverse for big-endian int conversion
                                    hash_int = int.from_bytes(output_hash_bytes[::-1], 'big')

                                    if hash_int <= target_int:
                                        print(f"!!! SHARE FOUND !!! Hash: {output_hash_hex}, Target: {client.target}")
                                        # Submit share
                                        # extranonce2_hex needs to be the hex representation of extranonce2_int
                                        # ntime needs to be the ntime from the job (job_params[7])
                                        client.submit_share(
                                            extranonce2=client.extranonce2_int.to_bytes(client.extranonce2_size, 'little').hex(),
                                            ntime=message["params"][7], # ntime from the job
                                            nonce=client.kernel_nonce.item(), # Convert numpy uint32 to Python int
                                            hash_result=output_hash_hex # Hash from kernel
                                        )
                                        # After finding a share, you might want to break from the inner loop
                                        # and wait for a new job, or continue mining if the pool allows.
                                        # For now, we'll continue to increment nonce.

                                    # Increment nonce for next iteration
                                    client.kernel_nonce = np.uint32(client.kernel_nonce + 1)
                                    current_nonce_attempt += 1

                                    # If we've exhausted the nonce space for this extranonce2, increment extranonce2
                                    if current_nonce_attempt >= max_nonces_per_job:
                                        client.extranonce2_int += 1
                                        # Check if extranonce2 overflows its allocated size
                                        if client.extranonce2_int >= (1 << (client.extranonce2_size * 8)):
                                            print("Extranonce2 exhausted for this job. Waiting for new job...")
                                            break # Break from inner loop to wait for new job
                                        extranonce2_bytes = client.extranonce2_int.to_bytes(client.extranonce2_size, 'little')
                                        client.kernel_nonce = np.uint32(0) # Reset nonce for new extranonce2
                                        current_nonce_attempt = 0 # Reset nonce attempt counter

                                        # Reconstruct input_data with new extranonce2
                                        input_data = construct_block_header(
                                            job_params=message["params"],
                                            extranonce1=client.extranonce1,
                                            extranonce2_bytes=extranonce2_bytes,
                                            kernel_nonce=client.kernel_nonce # Start with 0 nonce for new extranonce2
                                        )
                                        # Update input_buf with new input_data
                                        cl.enqueue_copy(queue, input_buf, input_data).wait()

                                except cl.LogicError as e:
                                    print(f"Error launching kernel: {e}")
                                    break # Break from inner mining loop on kernel error
                                except Exception as e:
                                    print(f"An error occurred during kernel execution: {e}")
                                    break # Break from inner mining loop on other errors

                                except cl.LogicError as e:
                                    print(f"Error launching kernel: {e}")
                                    break # Break from inner mining loop on kernel error
                                except Exception as e:
                                    print(f"An error occurred during kernel execution: {e}")
                                    break # Break from inner mining loop on other errors
                    else:
                        # Handle responses to sent messages (e.g., authorization response)
                        print(f"Received response: {message}")
                else:
                    # No message received, perhaps a timeout or connection closed
                    print("No message from pool. Reconnecting...")
                    client.sock.close()
                    if not client.connect() or not client.subscribe_and_authorize():
                        print("Failed to reconnect. Exiting.")
                        return
                    time.sleep(5) # Wait before retrying to prevent rapid-fire errors

    except Exception as e:
        print(f"An unexpected error occurred in main(): {e}")
        import traceback
        traceback.print_exc() # Print full traceback for debugging
    finally:
        # Restore stderr and close the log file
        if sys.stderr != sys.__stderr__:
            sys.stderr.close()
            sys.stderr = sys.__stderr__


if __name__ == "__main__":
    main()