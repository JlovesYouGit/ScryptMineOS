#version 450

// Complete Vulkan Compute Shader for Scrypt

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Input Buffer (Block Header)
layout (binding = 0) buffer InputDataBlock {
    uint input_data[];
};

// Output Buffer (Hash)
layout (binding = 1) buffer OutputDataBlock {
    uint output_data[];
};

// V Buffer (Scrypt Scratchpad)
layout (binding = 2) buffer VBuffer {
    uint V_data[];
};

// Scrypt constants
const uint SCRYPT_N = 1024;
const uint SCRYPT_r = 1;
const uint SCRYPT_p = 1;

// SHA256 constants
const uint sha256_k[64] = uint[64](
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
);

const uint sha256_init_state[8] = uint[8](
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
);



uint ror(uint x, int d) {
    return (x >> d) | (x << (32-d));
}

uint bswap(uint x) {
    return (((x & 0xff000000u) >> 24) |
            ((x & 0x00ff0000u) >>  8) |
            ((x & 0x0000ff00u) <<  8) |
            ((x & 0x000000ffu) << 24));
}

uint sigma0(uint h1) {
    return ror(h1, 2) ^ ror(h1, 13) ^ ror(h1, 22);
}

uint sigma1(uint h4) {
    return ror(h4, 6) ^ ror(h4, 11) ^ ror(h4, 25);
}

uint gamma0(uint a) {
    return ror(a, 7) ^ ror(a, 18) ^ (a >> 3);
}

uint gamma1(uint b) {
    return ror(b, 17) ^ ror(b, 19) ^ (b >> 10);
}

uint ch(uint x, uint y, uint z) {
    return z ^ (x & (y ^ z));
}

uint maj(uint x, uint y, uint z) {
    return (x & y) ^ ((x ^ y) & z);
}

void sha256_transform(inout SHA256_CTX ctx) {
    uint H[8];
    uint W[64];
    uint T0,T1;
    uint i;

    for (i=0; i<8; i++) {
        H[i] = ctx.state[i];
    }

    for (i=0; i<16; i++) {
        W[i] = bswap(ctx.block[i]);
    }

    for (i=16; i<64; i++) {
        W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16];
    }

    for (i=0; i<64; i++) {
        T0 = W[i] + H[7] + sigma1(H[4]) + ch(H[4], H[5], H[6]) + sha256_k[i];
        T1 = maj(H[0], H[1], H[2]) + sigma0(H[0]);
        H[7] = H[6];
        H[6] = H[5];
        H[5] = H[4];
        H[4] = H[3] + T0;
        H[3] = H[2];
        H[2] = H[1];
        H[1] = H[0];
        H[0] = T0 + T1;
    }

    for (i=0; i<8; i++) {
        ctx.state[i] += H[i];
    }
}

void sha256_init(inout SHA256_CTX ctx) {
    for (int i=0; i<8; i++) {
        ctx.state[i] = sha256_init_state[i];
    }
    ctx.length = 0;
    ctx.offset = 0;
}

void block_memcpy(inout SHA256_CTX ctx, uint dst, in uint src[], uint n) {
    for (uint i = 0; i < n; i++) {
        uint f = dst + i, bidx = f >> 2, bshift = (f & 3u) << 3;
        uint g = src[0] + i, didx = g >> 2, dshift = (g & 3u) << 3;
        uint bmsk = ~(0xffu << bshift);
        uint byte = (input_data[didx] >> dshift) & 0xffu;
        ctx.block[bidx] = (ctx.block[bidx] & bmsk) | (byte << bshift);
    }
}

void sha256_update(inout SHA256_CTX ctx, in uint data[], uint len) {
    ctx.length += len;
    uint data_offset = 0;
    while (len > 0) {
        uint fill = ctx.offset & 63u, accept = 64u - fill;
        if (accept > len) {
            accept = len;
        }
        block_memcpy(ctx, fill, data, accept);
        if (fill + accept == 64) {
            sha256_transform(ctx);
            ctx.offset = 0;
        }
        len -= accept;
        data_offset += accept;
    }
}

void sha256_final(inout SHA256_CTX ctx) {
    uint fill = ctx.offset & 63u, i;

    // block_memset(fill++, 0x80, 1);
    uint bidx = fill >> 2, bshift = (fill & 3u) << 3;
    ctx.block[bidx] = (ctx.block[bidx] & ~(0xffu << bshift)) | (0x80u << bshift);
    fill++;

    if (fill > 56) {
        // block_memset(fill, 0, 64u-fill);
        for (uint i = fill; i < 64; i++) {
            bidx = i >> 2; bshift = (i & 3u) << 3;
            ctx.block[bidx] = (ctx.block[bidx] & ~(0xffu << bshift));
        }
        sha256_transform(ctx);
        fill = 0;
    }

    // block_memset(fill, 0, 56u-fill);
    for (uint i = fill; i < 56; i++) {
        bidx = i >> 2; bshift = (i & 3u) << 3;
        ctx.block[bidx] = (ctx.block[bidx] & ~(0xffu << bshift));
    }
    ctx.block[14] = bswap(ctx.length >> 29);
    ctx.block[15] = bswap(ctx.length << 3);
    sha256_transform(ctx);

    for (i=0; i<8; i++) {
        ctx.state[i] = bswap(ctx.state[i]);
    }
}

void salsa20_8_core(inout uint state[16]) {
    uint x[16];
    for (int i = 0; i < 16; i++) x[i] = state[i];

    for (int i = 0; i < 4; ++i) {
        x[ 4] ^= ror(x[ 0]+x[12], 7);  x[ 8] ^= ror(x[ 4]+x[ 0], 9);
        x[12] ^= ror(x[ 8]+x[ 4],13);  x[ 0] ^= ror(x[12]+x[ 8],18);
        x[ 9] ^= ror(x[ 5]+x[ 1], 7);  x[13] ^= ror(x[ 9]+x[ 5], 9);
        x[ 1] ^= ror(x[13]+x[ 9],13);  x[ 5] ^= ror(x[ 1]+x[13],18);
        x[14] ^= ror(x[10]+x[ 6], 7);  x[ 2] ^= ror(x[14]+x[10], 9);
        x[ 6] ^= ror(x[ 2]+x[14],13);  x[10] ^= ror(x[ 6]+x[ 2],18);
        x[ 3] ^= ror(x[15]+x[11], 7);  x[ 7] ^= ror(x[ 3]+x[15], 9);
        x[11] ^= ror(x[ 7]+x[ 3],13);  x[15] ^= ror(x[11]+x[ 7],18);

        x[ 1] ^= ror(x[ 0]+x[ 3], 7);  x[ 2] ^= ror(x[ 1]+x[ 0], 9);
        x[ 3] ^= ror(x[ 2]+x[ 1],13);  x[ 0] ^= ror(x[ 3]+x[ 2],18);
        x[ 6] ^= ror(x[ 5]+x[ 4], 7);  x[ 7] ^= ror(x[ 6]+x[ 5], 9);
        x[ 4] ^= ror(x[ 7]+x[ 6],13);  x[ 5] ^= ror(x[ 4]+x[ 7],18);
        x[11] ^= ror(x[10]+x[ 9], 7);  x[ 8] ^= ror(x[11]+x[10], 9);
        x[ 9] ^= ror(x[ 8]+x[11],13);  x[10] ^= ror(x[ 9]+x[ 8],18);
        x[12] ^= ror(x[15]+x[14], 7);  x[13] ^= ror(x[12]+x[15], 9);
        x[14] ^= ror(x[13]+x[12],13);  x[15] ^= ror(x[14]+x[13],18);
    }

    for (int i = 0; i < 16; i++) state[i] += x[i];
}

void blockmix_salsa8(inout uint B[32], inout uint Y[32]) {
    uint X[16];
    for (int i = 0; i < 16; i++) X[i] = B[16 * (2 * SCRYPT_r - 1) + i];

    for (int i = 0; i < 2 * SCRYPT_r; i++) {
        for (int j = 0; j < 16; j++) {
            X[j] ^= B[i * 16 + j];
        }
        salsa20_8_core(X);
        for (int j = 0; j < 16; j++) {
            Y[i * 16 + j] = X[j];
        }
    }
}

void scryptROMix(inout uint B[32]) {
    for (int i = 0; i < SCRYPT_N; i++) {
        for (int j = 0; j < 32; j++) {
            V_data[i * 32 + j] = B[j];
        }
        blockmix_salsa8(B, B);
    }

    for (int i = 0; i < SCRYPT_N; i++) {
        uint j = B[16 * (2 * SCRYPT_r - 1)] & (SCRYPT_N - 1);
        for (int k = 0; k < 32; k++) {
            B[k] ^= V_data[j * 32 + k];
        }
        blockmix_salsa8(B, B);
    }
}

void pbkdf2_hmac_sha256(in uint password[], uint password_len, in uint salt[], uint salt_len, uint iterations, uint dkLen, out uint derived_key[]) {
    struct SHA256_CTX {
        uint state[8];
        uint block[16];
        uint offset;
        uint length;
    };
    SHA256_CTX ctx;
    uint T[8];
    uint U[8];
    uint i_as_salt[1];

    for (int i = 1; i <= (dkLen + 31) / 32; i++) {
        i_as_salt[0] = bswap(i);
        sha256_init(ctx);
        sha256_update(ctx, password, password_len);
        sha256_update(ctx, salt, salt_len);
        sha256_update(ctx, i_as_salt, 4);
        sha256_final(ctx);
        for(int j=0; j<8; j++) {
            T[j] = ctx.state[j];
            U[j] = ctx.state[j];
        }

        for (int j = 1; j < iterations; j++) {
            sha256_init(ctx);
            sha256_update(ctx, password, password_len);
            sha256_update(ctx, U, 32);
            sha256_final(ctx);
            for(int k=0; k<8; k++) {
                U[k] = ctx.state[k];
                T[k] ^= U[k];
            }
        }

        for(int j=0; j<8; j++) {
            derived_key[(i-1)*8 + j] = T[j];
        }
    }
}

void main() {
    uint B_uints[32];
    uint final_hash[8];
    uint nonce = 0; // Example nonce

    uint password[20];
    for(int i=0; i<20; i++) {
        password[i] = input_data[i];
    }

    uint salt[1];
    salt[0] = nonce;

    pbkdf2_hmac_sha256(password, 80, salt, 4, 1, 128, B_uints);

    scryptROMix(B_uints);

    pbkdf2_hmac_sha256(password, 80, B_uints, 128, 1, 32, final_hash);

    for(int i=0; i<8; i++) {
        output_data[i] = final_hash[i];
    }
}
